localparselet,t,n=require('qamar.parser.parselet'),require('qamar.tokenizer.types'),require('qamar.parser.types')local functionget_precedence(tokenizer)localnext=tokenizer.peek()if next then localinfix=parselet.infix[next.type]if infix then returninfix.precedence end endreturn0endlocal functionwrap(node,parser)if type(node)~='table' then node={type=node} endreturnfunction()localret=parser()if ret then ret.type=node.typeret.typename=n[node.type]if node.rewrite then node.rewrite(ret) endif node.string then setmetatable(ret,{__tostring=node.string}) end endreturnretendendreturnfunction(tokenizer)localp={tokenizer=tokenizer}localalt,seq,opt,zom=tokenizer.combinators.alt,tokenizer.combinators.seq,tokenizer.combinators.opt,tokenizer.combinators.zomfunctionp.expression(precedence)precedence=precedence or 0tokenizer.begin()localtoken=tokenizer.take()if not token then tokenizer.undo()return endlocalprefix=parselet.prefix[token.type]if not prefix then tokenizer.undo()return endlocalleft=prefix:parse(p,token)if not left then tokenizer.undo()return endwhile precedence<get_precedence(tokenizer) do token=tokenizer.peek()if not token then tokenizer.commit()returnleft endlocalinfix=parselet.infix[token.type]if not infix then tokenizer.commit()returnleft endtokenizer.begin()tokenizer.take()localright=infix:parse(p,left,token)if not right then tokenizer.undo()tokenizer.undo()returnleft else tokenizer.commit()left=right end endtokenizer.commit()returnleftendp.fieldsep=wrap({type=n.fieldsep,string=function()return','end},function()localret=alt(t.comma,t.semicolon)()if ret then ret={pos=ret.pos,value=ret.value} endreturnretend)p.field=alt(wrap({type=n.field_raw,string=function(self)returntconcat({'[',tostring(self[2]),']=',tostring(self[5])})end},seq(t.lbracket,p.expression,t.rbracket,t.assignment,p.expression)),wrap({type=n.field_name,string=function(self)returntostring(self[1])..'='..tostring(self[3])end},seq(t.name,t.assignment,p.expression)),p.expression)p.fieldlist=wrap({type=n.fieldlist,string=function(self)localret={tostring(self[1])}for _,x in ipairs(self[2]) do table.insert(ret,',')table.insert(ret,tostring(x[2])) endreturntconcat(ret)end},seq(p.field,zom(seq(p.fieldsep,p.field)),opt(p.fieldsep)))p.tableconstructor=function()tokenizer.begin()localret=p.expression()if ret and ret.type==n.tableconstructor then tokenizer.commit()returnret endtokenizer.undo()endp.namelist=wrap({type=n.namelist,string=function(self)localret={tostring(self[1])}for _,x in ipairs(self[2]) do table.insert(ret,',')table.insert(ret,tostring(x[2])) endreturntconcat(ret)end},seq(t.name,zom(seq(t.comma,t.name))))p.vararg=wrap({type=n.vararg,string=function()return'...'end},alt(t.tripledot))p.parlist=alt(wrap({type=n.parlist,string=function(self)localret=tostring(self[1])if self[2][1] then ret=tconcat({ret,',...'}) endreturnretend},seq(p.namelist,opt(seq(t.comma,p.vararg)))),p.vararg)p.explist=wrap({type=n.explist,string=function(self)localret={tostring(self[1])}for _,x in ipairs(self[2]) do table.insert(ret,',')table.insert(ret,tostring(x[2])) endreturntconcat(ret)end},seq(p.expression,zom(seq(t.comma,p.expression))))p.attrib=wrap({type=n.attrib,string=function(self)if self[1] then returntconcat({'<',tostring(self[2]),'>'}) else return'' endend},opt(seq(t.less,t.name,t.greater)))p.attnamelist=wrap({type=n.attnamelist,string=function(self)localret=tconcat({tostring(self[1]),tostring(self[2])})for _,x in ipairs(self[3]) do ret=tconcat({ret,',',tostring(x[2]),tostring(x[3])}) endreturnretend},seq(t.name,p.attrib,zom(seq(t.comma,t.name,p.attrib))))p.retstat=wrap({type=n.retstat,string=function(self)localret='return'if self[2].type then ret=tconcat({ret,' ',tostring(self[2])}) endreturnretend},seq(t.kw_return,opt(p.explist),opt(t.semicolon)))p.label=wrap({type=n.label,string=function(self)returntconcat({'::',tostring(self[2]),'::'})end},seq(t.doublecolon,t.name,t.doublecolon))p.funcname=wrap({type=n.funcname,string=function(self)localret=tostring(self[1])for _,x in ipairs(self[2]) do ret=tconcat({ret,'.',tostring(x[2])}) endif self[3][1] then ret=tconcat({ret,':',tostring(self[3][2])}) endreturnretend},seq(t.name,zom(seq(t.dot,t.name)),opt(seq(t.colon,t.name))))p.args=alt(wrap({type=n.args,string=function(self)returntostring(self[2])end},seq(t.lparen,p.explist,t.rparen)),p.tableconstructor,wrap({type=n.args,string=function(self)returnself.valueend},alt(t.string)))p.block=wrap({type=n.block,string=function(self)localret={}for i,x in ipairs(self[1]) do if i>1 then table.insert(ret,' ') endtable.insert(ret,tostring(x)) endif #ret>0 then table.insert(ret,' ') endtable.insert(ret,tostring(self[2]))returntconcat(ret)end},seq(zom(function()returnp.stat()end),opt(p.retstat)))p.funcbody=wrap({type=n.funcbody,string=function(self)localret='('if self[2][1] then ret=tconcat({ret,tostring(self[2][1])}) endret=tconcat({ret,')',tostring(self[4]),'end'})returnretend},seq(t.lparen,opt(p.parlist),t.rparen,p.block,t.kw_end))p.functiondef=function()tokenizer.begin()localret=p.expression()if ret and ret.type==n.functiondef then tokenizer.commit()returnret endtokenizer.undo()endp.var=function()tokenizer.begin()localret=p.expression()if ret and (ret.type==n.name or ret.type==n.table_nameaccess or ret.type==n.table_rawaccess) then tokenizer.commit()returnret endtokenizer.undo()endp.varlist=wrap({type=n.varlist,string=function(self)localret=tostring(self[1])for _,x in ipairs(self[2]) do ret=tconcat({ret,',',tostring(x[2])}) endreturnretend},seq(p.var,zom(seq(t.comma,p.var))))p.stat=alt(wrap({type=n.stat_empty,string=function()return';'end},seq(t.semicolon)),wrap({type=n.stat_localvar,string=function(self)localret=tconcat({'local',tostring(self[2])})if self[3][1] then ret=tconcat({ret,'=',tostring(self[3][2])}) endreturnretend},seq(t.kw_local,p.attnamelist,opt(seq(t.assignment,p.explist)))),wrap(n.stat_label,p.label),wrap({type=n.stat_break,string=function()return'break'end},seq(t.kw_break)),wrap({type=n.stat_goto,string=function(self)returntconcat({'goto',tostring(self[2])})end},seq(t.kw_goto,t.name)),wrap({type=n.localfunc,string=function(self)returntconcat({'local function',tostring(self[3]),tostring(self[4])})end},seq(t.kw_local,t.kw_function,t.name,p.funcbody)),wrap({type=n.func,string=function(self)returntconcat({'function',tostring(self[2]),tostring(self[3])})end},seq(t.kw_function,p.funcname,p.funcbody)),wrap({type=n.for_num,string=function(self)localret='for '..tostring(self[2])..'='..tostring(self[4])..','..tostring(self[6])if self[7][1] then ret=ret..','..tostring(self[7][2]) endreturnret..' do '..tostring(self[9])..' end'end},seq(t.kw_for,t.name,t.assignment,p.expression,t.comma,p.expression,opt(seq(t.comma,p.expression)),t.kw_do,p.block,t.kw_end)),wrap({type=n.stat_for_iter,string=function(self)return'for '..tostring(self[2])..' in '..tostring(self[4])..' do '..tostring(self[6])..' end'end},seq(t.kw_for,p.namelist,t.kw_in,p.explist,t.kw_do,p.block,t.kw_end)),wrap({type=n.stat_if,string=function(self)localret='if '..tostring(self[2])..' then '..tostring(self[4])for _,x in ipairs(self[5]) do ret=ret..' elseif '..tostring(x[2])..' then '..tostring(x[4]) endif self[6][1] then ret=ret..' else '..tostring(self[6][2]) endret=ret..' end'returnretend},seq(t.kw_if,p.expression,t.kw_then,p.block,zom(seq(t.kw_elseif,p.expression,t.kw_then,p.block)),opt(seq(t.kw_else,p.block)),t.kw_end)),wrap({type=n.stat_do,string=function(self)return'do '..tostring(self[2])..' end'end},seq(t.kw_do,p.block,t.kw_end)),wrap({type=n.stat_while,string=function(self)return'while '..tostring(self[2])..' do '..tostring(self[4])..' end'end},seq(t.kw_while,p.expression,t.kw_do,p.block,t.kw_end)),wrap({type=n.stat_repeat,string=function(self)return'repeat '..tostring(self[2])..' until '..tostring(self[4])end},seq(t.kw_repeat,p.block,t.kw_until,p.expression)),wrap({type=n.stat_assign,string=function(self)returntostring(self[1])..'='..tostring(self[3])end},seq(p.varlist,t.assignment,p.explist)),function()tokenizer.begin()localret=p.expression()if ret and ret.type==n.functioncall then tokenizer.commit()returnret endtokenizer.undo()end)p.chunk=wrap(n.chunk,function()if tokenizer.peek() then localret=p.block()returnret and not tokenizer.peek() and ret or nil endend)returnpend